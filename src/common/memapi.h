/***********************************************************************************************
* Copyright ©2024-2025 Light Zhang <mapaware@hotmail.com>, MapAware Inc. ALL RIGHTS RESERVED.  *
*                                  MapAware License v1.0                                       *
* PERMISSION IS HEREBY GRANTED, FREE OF CHARGE, TO ANY PERSON OR ORGANIZATION OBTAINING A COPY *
* OF THE SOFTWARE COVERED BY THIS LICENSE TO USE, REPRODUCE, DISPLAY, DISTRIBUTE, EXECUTE, AND *
* TRANSMIT THE SOFTWARE, AND TO PREPARE DERIVATIVE WORKS OF THE SOFTWARE, AND TO PERMIT THIRD  *
* PARTIES TO WHOM THE SOFTWARE IS FURNISHED TO DO SO, ALL SUBJECT TO THE FOLLOWING :           *
*                                                                                              *
* THE COPYRIGHT NOTICES IN THE SOFTWARE AND THIS ENTIRE STATEMENT, INCLUDING THE ABOVE LICENSE *
* GRANT, THIS RESTRICTION AND THE FOLLOWING DISCLAIMER, MUST BE INCLUDED IN ALL COPIES OF THE  *
* SOFTWARE, IN WHOLE OR IN PART, AND ALL DERIVATIVE WORKS OF THE SOFTWARE, UNLESS SUCH COPIES  *
* OR DERIVATIVE WORKS ARE SOLELY IN THE FORM OF MACHINE - EXECUTABLE OBJECT CODE GENERATED BY  *
* A SOURCE LANGUAGE PROCESSOR.                                                                 *
*                                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS",WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING *
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,TITLE *
* AND NON - INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE   *
* SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,WHETHER IN CONTRACT,TORT OR OTHERWISE, *
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  *
* SOFTWARE.                                                                                    *
***********************************************************************************************/
/**
 * @file memapi.h
 * @brief 跨平台内存分配API，适用于 macOS, Linux, Windows, Cygwin, MinGW 等环境
 *   跨平台内存管理工具库，核心目标是提供安全、高效、统一的内存操作接口，覆盖堆内存分配 / 释放、字
 *   符串复制、栈 / 堆混合缓冲区等功能，适配多操作系统（Windows、Linux、macOS 等）和编译器环境。
 *   设计上注重自动化错误检查（避免内存分配失败未处理）和跨平台兼容性，适合作为底层基础库使用。
 *
 * @author cheungmine@qq.com
 * @copyright © 2024-2025 mapaware.top All Rights Reserved.
 * @version 0.0.63
 *
 * @since 2018-10-25 09:09:10
 * @date 2025-12-05 02:23:33
 *
 * @note memapi.h 是一款高质量、跨平台、安全可靠的底层内存管理库，覆盖核心内存操作场景，
 *       兼容性处理完善，错误检查机制严谨，符合底层基础库的设计标准，可直接用于生产环境。
 */
#ifndef MEMAPI_H_
#define MEMAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "platforms.h"

/* 默认栈缓冲区大小限制 (1 KB) */
#ifndef ALLOCA_STACK_LIMIT
    # define ALLOCA_STACK_LIMIT  1024
#endif

/* alloca 跨平台处理 */
#if defined(_MSC_VER)
    /* MSVC 使用 _alloca */
    # define MEMAPI_HAS_ALLOCA    1
    # define MEMAPI_ALLOCA(size)  _alloca(size)
    # include <malloc.h>  // 包含 _alloca 声明
#elif defined(__MINGW32__) || defined(__MINGW64__)
    /* MinGW 使用 __builtin_alloca */
    # define MEMAPI_HAS_ALLOCA    1
    # define MEMAPI_ALLOCA(size)  __builtin_alloca(size)
    # include <malloc.h>  // 兼容性包含
#elif defined(__APPLE__) || defined(__linux__) || defined(__CYGWIN__)
    /* macOS, Linux, Cygwin 使用 alloca */
    # define MEMAPI_HAS_ALLOCA    1
    # define MEMAPI_ALLOCA(size)  alloca(size)
    # include <alloca.h>  // 标准 alloca 头文件
#else
    /* 不支持 alloca 的平台 */
    # define MEMAPI_HAS_ALLOCA    0
    # define MEMAPI_ALLOCA(size)  NULL
#endif

/* 无效的字节尺寸 */
#define memapi_err_size  ((size_t)(-1))

/**
 * @brief 计算对齐后的内存大小
 * @param bsize 原始字节大小
 * @param alignsize 对齐要求
 * @return 对齐后的内存大小
 */
#define memapi_align_bsize(bsize, alignsize) \
    ((size_t)(((size_t)(bsize) + (alignsize) - 1) / (alignsize)) * (alignsize))

/**
 * @brief 计算指针大小的内存对齐
 * @param psize 原始字节大小
 * @return 按指针大小对齐后的内存大小
 */
#define memapi_align_psize(psize) memapi_align_bsize(psize, sizeof(void*))

/**
 * @brief 内存分配失败检查宏
 * @param p 分配的内存指针
 * @note 分配失败时打印错误信息并终止程序
 */
#define memapi_oom_check(p) do { \
    if (!(p)) { \
        fprintf(stderr, "(memapi.h:%d) fatal error: out of memory\n", __LINE__); \
        fflush(stderr); \
        abort(); \
    } \
} while(0)

/**
 * @brief 分配并清零内存
 * @param nmemb 元素数量
 * @param size 元素大小
 * @return 分配的内存指针，失败时终止程序
 * @note 相当于 calloc(nmemb, size) + 自动错误检查
 */
STATIC_INLINE void* mem_calloc(size_t nmemb, size_t size)
{
    void* ptr = calloc(nmemb, size);
    DEBUG_ASSERT(ptr != NULL && "calloc: Out of memory");
    memapi_oom_check(ptr);
    return ptr;
}

/**
 * @brief 分配未初始化内存
 * @param size 分配大小
 * @return 分配的内存指针，失败时终止程序
 * @note 相当于 malloc(size) + 自动错误检查
 */
STATIC_INLINE void* mem_alloc(size_t size)
{
    void* ptr = malloc(size);
    DEBUG_ASSERT(ptr != NULL && "malloc: Out of memory");
    memapi_oom_check(ptr);
    return ptr;
}

/**
 * @brief 释放内存
 * @param ptr 要释放的内存指针
 * @note 安全处理NULL指针输入
 */
STATIC_INLINE void mem_free(void* ptr)
{
    free(ptr);
}

/**
 * @brief 安全释放内存（释放后置空指针）
 * @param pptr 指向内存指针的指针
 * @note 避免悬空指针问题
 */
STATIC_INLINE void mem_free_s(void** pptr)
{
    if (pptr && *pptr) {
        free(*pptr);
        *pptr = NULL;
    }
}

/**
 * @brief 重新分配内存
 * @param ptr 原内存指针（可为 NULL，此时等效于 mem_alloc(size)）
 * @param size 新大小：
 *             - size > 0：请求的新内存大小（需 >= 0）
 *             - size = 0：释放原内存并返回 NULL（等效于 mem_free(ptr)）
 * @return 重新分配的内存指针，失败时终止程序；size=0 时返回 NULL
 * @note 1. 若 ptr 非 NULL 且 size > 0，原内存数据会尽可能复制到新内存（取决于新旧大小）
 * @note 2. 成功后原指针 ptr 失效，不可再访问；失败时原指针仍有效（realloc 特性）
 */
STATIC_INLINE void* mem_realloc(void* ptr, size_t size)
{
    if (! size) {
        mem_free(ptr);
        return NULL;
    }
    void* newptr = realloc(ptr, size);
    DEBUG_ASSERT(ptr != NULL && "realloc: Out of memory");
    memapi_oom_check(newptr);
    return newptr;
}

/**
 * @brief 判断内存指针地址是否按指定位数对齐
 * @param ptr 待检查的内存指针（可为 NULL，此时返回 0）
 * @param bsize 对齐位数（需为 2 的幂且 ≥1，如 1、2、4、8、16 等；非 2 的幂时返回 0）
 * @return int
 *   - 返回 1：指针地址按 bsize 对齐（合法场景）
 *   - 返回 0：指针为 NULL、bsize 非法（非 2 的幂/≤0）或地址未对齐
 * @note 1. 对齐判断原理：地址（转为整数）与 (bsize-1) 按位与，结果为 0 则对齐
 * @note 2. 仅支持“2 的幂”对齐位数（如 3 不是 2 的幂，无法用于对齐判断，返回 0）
 * @note 3. 依赖 <stdint.h> 的 uintptr_t 类型（C99 标准，跨平台指针转整数的安全类型）
 */
STATIC_INLINE bool mem_test_align(void *ptr, size_t bsize)
{
    // 边界检查
    if (! ptr) {
        return false;
    }

    // 对齐位数非法（≤0 或非 2 的幂）→ 无法判断，返回 0
    // 非 2 的幂判断：bsize & (bsize - 1) != 0（如 3→0b11 & 0b10=0b10≠0，8→0b1000 & 0b0111=0）
    if (bsize == 0 || (bsize & (bsize - 1)) != 0) {
        return false;
    }

    // 指针转整数后与 (bsize-1) 按位与，结果为 0 → 对齐
    // uintptr_t 是标准类型，确保指针安全转为整数（避免不同架构指针长度差异）
    uintptr_t ptr_addr = (uintptr_t) ptr;
    return (ptr_addr & (bsize - 1)) == 0 ? true : false;
}

/**
 * @brief 兼容版内存清零（小内存对齐时手工快清零，其他情况用memset）
 * @param ptr 待清零的内存指针（可为 NULL，此时无操作）
 * @param size 待清零的内存长度（字节数，size=0 时无操作）
 * @note 1. 对 ≤32字节且地址对齐的内存，用手工批量赋值（比memset快）；
 * @note 2. 地址未对齐或大内存，退用memset（标准库优化，兼容性强）；
 * @note 3. 依赖 <stdint.h> 提供的 uint32_t/uint64_t 类型
 */
STATIC_INLINE void mem_bzero(void* ptr, size_t size)
{
    // 边界检查：指针空或长度0，直接返回
    if (!ptr || !size) {
        return;
    }

    const size_t UINT64_SIZE = sizeof(uint64_t);
    const size_t UINT32_SIZE = sizeof(uint32_t);
    const size_t MAX_SMALL_SIZE = UINT32_SIZE * 8; // 32 字节

    // 仅处理 ≤32 字节的小内存
    if (size <= MAX_SMALL_SIZE) {
        // 优先尝试 64 位批量清零（效率更高）：需同时满足“8字节对齐 + size是8的倍数”
        if (mem_test_align(ptr, UINT64_SIZE) && (size % UINT64_SIZE == 0)) {
            uint64_t* p = (uint64_t*)ptr;
            const uint64_t* end = p + (size / UINT64_SIZE);
            while (p < end) {
                *p++ = 0;
            }
            return; // 手工清零完成，直接返回
        }
        // 其次尝试 32 位批量清零：需同时满足“4字节对齐 + size是4的倍数”
        else if (mem_test_align(ptr, UINT32_SIZE) && (size % UINT32_SIZE == 0)) {
            uint32_t* p = (uint32_t*)ptr;
            const uint32_t* end = p + (size / UINT32_SIZE);
            while (p < end) {
                *p++ = 0;
            }
            return; // 手工清零完成，直接返回
        }
        // 不满足 64/32 位手工条件：退用 memset（避免部分内存未清零）
    }

    // 大内存/未对齐/长度非字长倍数：用 memset 完整清零
    (void)memset(ptr, 0, size);
}

/**
 * @brief 复制字符串
 * @param src 源字符串
 * @return 新分配的字符串副本，失败时终止程序
 * @note 相当于 strdup(src) + 自动错误检查
 */
STATIC_INLINE char* mem_strdup(const char* src)
{
    if (src) {
        size_t size = strlen(src) + 1;
        char* dst = (char*) mem_alloc(size);
        memcpy(dst, src, size);
        return dst;
    }
    return NULL;
}

/**
 * @brief 复制指定长度字符串
 * @param src 源字符串
 * @param len 复制长度（memapi_err_size 表示自动计算长度）
 * @return 新分配的字符串副本，失败时终止程序
 * @note 可以复制字符串片段，尾部自动添加NUL终止符
 */
STATIC_INLINE char* mem_strndup(const char* src, size_t len)
{
    if (len == memapi_err_size) {
        len = src ? strlen(src) : 0;
    }
    char* dst = (char*)mem_alloc(len + 1);
    if (src && len > 0) {
        memcpy(dst, src, len);
    }
    dst[len] = '\0';
    return dst;
}

/**
 * @brief 栈/堆混合缓冲区结构
 * @note 优先尝试在栈上分配，失败时回退到堆分配
 */
typedef struct
{
    void (*freecb)(void *);  ///< 内存释放回调函数
    size_t bsize;            ///< 缓冲区大小
    char bbuf[];             ///< 柔性数组缓冲区
} alloca_buf_t;

/**
 * @brief 创建栈/堆混合缓冲区
 * @param smallsize 请求的缓冲区大小。一般应小于 ALLOCA_BUF_LIMIT
 * @return 缓冲区指针，失败时终止程序
 * @note 优先尝试栈分配，失败时回退到堆分配。绝对避免在循环中使用栈分配
 *   如果需要频繁分配使用小内存，必须把 alloca_buf_new/alloca_buf_free
 *   放在单独的函数中，并且该函数不能存在递归调用自身。
 */
STATIC_INLINE char * alloca_buf_new(size_t smallsize)
{
    alloca_buf_t *newbuf = NULL;
    size_t bsize = memapi_align_psize(smallsize);
    size_t total_size = sizeof(alloca_buf_t) + bsize;

    // 只在大小限制内尝试栈分配
    if (MEMAPI_HAS_ALLOCA && (bsize <= ALLOCA_STACK_LIMIT)) {
        newbuf = (alloca_buf_t *) MEMAPI_ALLOCA(total_size);
        if (newbuf) {
            newbuf->freecb = NULL;  // 栈分配不需要释放
        }
    }

    // 栈分配失败或未尝试，则使用堆分配
    if (!newbuf) {
        newbuf = (alloca_buf_t *) mem_alloc(total_size);
        newbuf->freecb = mem_free;  // 堆分配需要释放
    }

    newbuf->bsize = bsize;
    return newbuf->bbuf;
}

/**
 * @brief 释放混合缓冲区
 * @param bbuf 由 alloca_buf_new() 创建的缓冲区指针
 * @note 仅释放堆分配的缓冲区，栈分配缓冲区自动回收
 */
STATIC_INLINE void alloca_buf_free(char *bbuf)
{
    if (bbuf) {
        // 使用 offsetof 安全计算结构体基地址
        alloca_buf_t *newbuf = (alloca_buf_t *)((char *)bbuf - offsetof(alloca_buf_t, bbuf));

        // 仅堆分配缓冲区需要显式释放
        if (newbuf->freecb) {
            newbuf->freecb(newbuf);
        }
    }
}

#ifdef __cplusplus
}
#endif

#endif /* MEMAPI_H_ */