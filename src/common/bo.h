/***********************************************************************************************
* Copyright ©2024-2025 Light Zhang <mapaware@hotmail.com>, MapAware Inc. ALL RIGHTS RESERVED.  *
*                                  MapAware License v1.0                                       *
* PERMISSION IS HEREBY GRANTED, FREE OF CHARGE, TO ANY PERSON OR ORGANIZATION OBTAINING A COPY *
* OF THE SOFTWARE COVERED BY THIS LICENSE TO USE, REPRODUCE, DISPLAY, DISTRIBUTE, EXECUTE, AND *
* TRANSMIT THE SOFTWARE, AND TO PREPARE DERIVATIVE WORKS OF THE SOFTWARE, AND TO PERMIT THIRD  *
* PARTIES TO WHOM THE SOFTWARE IS FURNISHED TO DO SO, ALL SUBJECT TO THE FOLLOWING :           *
*                                                                                              *
* THE COPYRIGHT NOTICES IN THE SOFTWARE AND THIS ENTIRE STATEMENT, INCLUDING THE ABOVE LICENSE *
* GRANT, THIS RESTRICTION AND THE FOLLOWING DISCLAIMER, MUST BE INCLUDED IN ALL COPIES OF THE  *
* SOFTWARE, IN WHOLE OR IN PART, AND ALL DERIVATIVE WORKS OF THE SOFTWARE, UNLESS SUCH COPIES  *
* OR DERIVATIVE WORKS ARE SOLELY IN THE FORM OF MACHINE - EXECUTABLE OBJECT CODE GENERATED BY  *
* A SOURCE LANGUAGE PROCESSOR.                                                                 *
*                                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS",WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING *
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,TITLE *
* AND NON - INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE   *
* SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,WHETHER IN CONTRACT,TORT OR OTHERWISE, *
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  *
* SOFTWARE.                                                                                    *
***********************************************************************************************/
/**
 * @file bo.h
 * @brief Byte Converter for 2, 4, 8 bytes numeric types
 *
 * @author cheungmine@qq.com
 * @copyright © 2024-2025 mapaware.top All Rights Reserved.
 * @version 0.0.42
 *
 * @since 2013-06-19 12:09:10
 * @date 2025-12-05 02:23:33
 *
 * @note
 *
 * Big Endian: XDR (big endian) encoding of numeric types
 *
 *                   Register
 *                  0x0A0B0C0D
 *      Memory         | | | |
 *       |..|          | | | |
 *  a+0: |0A|<---------+ | | |
 *  a+1: |0B|<-----------+ | |
 *  a+2: |0C|<-------------+ |
 *  a+3: |0D|<---------------+
 *       |..|
 *
 * Little Endian: NDR (little endian) encoding of numeric types
 *
 *   Register
 *  0x0A0B0C0D
 *     | | | |              Memory
 *     | | | |               |..|
 *     | | | +--------> a+0: |0D|
 *     | | +----------> a+1: |0C|
 *     | +------------> a+2: |0B|
 *     +--------------> a+3: |0A|
 *                           |..|
 */
#ifndef BYTE_ORDER_H__
#define BYTE_ORDER_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "platforms.h"

#if __STDC_VERSION__ >= 201112L
static_assert(sizeof(uint16_t) == 2, "uint16_t must be 2 bytes");
static_assert(sizeof(uint32_t) == 4, "uint32_t must be 4 bytes");
static_assert(sizeof(uint64_t) == 8, "uint64_t must be 8 bytes");
#endif

/* 编译时字节序检测 */
#if defined(PLATFORM_WINDOWS)

    #define BO_LITTLE_ENDIAN 1
    #define BO_BIG_ENDIAN    0
    #define BO_BYTE_ORDER    1 // 小端

    // 定义字节交换函数
    #define BO_bswap16(x)  _byteswap_ushort(x)
    #define BO_bswap32(x)  _byteswap_ulong(x)
    #define BO_bswap64(x)  _byteswap_uint64(x)

#elif defined(__APPLE__) || defined(__linux__) || defined(__unix__) || defined(__gnu_linux__)
    /* 类Unix平台 */
    #include <endian.h>

    // 定义统一的布尔值宏
    #define BO_LITTLE_ENDIAN (__BYTE_ORDER == __LITTLE_ENDIAN)
    #define BO_BIG_ENDIAN    (__BYTE_ORDER == __BIG_ENDIAN)
    #define BO_BYTE_ORDER    __BYTE_ORDER

    // 使用编译器内置函数
    #if defined(__GNUC__) || defined(__clang__)
        #define BO_bswap16(x)  __builtin_bswap16(x)
        #define BO_bswap32(x)  __builtin_bswap32(x)
        #define BO_bswap64(x)  __builtin_bswap64(x)
    #else
        // 通用实现
        static inline uint16_t BO_bswap16(uint16_t x) {
            return (x >> 8) | (x << 8);
        }

        static inline uint32_t BO_bswap32(uint32_t x) {
            return ((x & 0xFF000000) >> 24) |
                   ((x & 0x00FF0000) >> 8)  |
                   ((x & 0x0000FF00) << 8)  |
                   ((x & 0x000000FF) << 24);
        }

        static inline uint64_t BO_bswap64(uint64_t x) {
            return ((x & 0xFF00000000000000ULL) >> 56) |
                   ((x & 0x00FF000000000000ULL) >> 40) |
                   ((x & 0x0000FF0000000000ULL) >> 24) |
                   ((x & 0x000000FF00000000ULL) >> 8)  |
                   ((x & 0x00000000FF000000ULL) << 8)  |
                   ((x & 0x0000000000FF0000ULL) << 24) |
                   ((x & 0x000000000000FF00ULL) << 40) |
                   ((x & 0x00000000000000FFULL) << 56);
        }
    #endif

#else
    #error "Platform not supported. Please define byte order manually."
#endif

/* 根据字节序定义转换函数 */
#if BO_LITTLE_ENDIAN
    #define BO_htobe16(x) BO_bswap16(x)
    #define BO_htobe32(x) BO_bswap32(x)
    #define BO_htobe64(x) BO_bswap64(x)
    #define BO_htole16(x) (x)
    #define BO_htole32(x) (x)
    #define BO_htole64(x) (x)

    static inline float BO_float32_htobe(float value) {
        uint32_t temp;
        memcpy(&temp, &value, sizeof(temp));
        temp = BO_bswap32(temp);
        memcpy(&value, &temp, sizeof(value));
        return value;
    }

    static inline double BO_float64_htobe(double value) {
        uint64_t temp;
        memcpy(&temp, &value, sizeof(temp));
        temp = BO_bswap64(temp);
        memcpy(&value, &temp, sizeof(value));
        return value;
    }

    #define BO_float32_htole(x)  (x)
    #define BO_float64_htole(x)  (x)

#else
    #define BO_htobe16(x) (x)
    #define BO_htobe32(x) (x)
    #define BO_htobe64(x) (x)
    #define BO_float32_htobe(x) (x)
    #define BO_float64_htobe(x) (x)

    #define BO_htole16(x) BO_bswap16(x)
    #define BO_htole32(x) BO_bswap32(x)
    #define BO_htole64(x) BO_bswap64(x)

    static inline float BO_float32_htole(float value) {
        uint32_t temp;
        memcpy(&temp, &value, sizeof(temp));
        temp = BO_bswap32(temp);
        memcpy(&value, &temp, sizeof(value));
        return value;
    }

    static inline double BO_float64_htole(double value) {
        uint64_t temp;
        memcpy(&temp, &value, sizeof(temp));
        temp = BO_bswap64(temp);
        memcpy(&value, &temp, sizeof(value));
        return value;
    }
#endif

// 反向转换
#define BO_betoh16(x) BO_htobe16(x)
#define BO_betoh32(x) BO_htobe32(x)
#define BO_betoh64(x) BO_htobe64(x)
#define BO_letoh16(x) BO_htole16(x)
#define BO_letoh32(x) BO_htole32(x)
#define BO_letoh64(x) BO_htole64(x)

#define BO_float32_betoh(x)  BO_float32_htobe(x)
#define BO_float64_betoh(x)  BO_float64_htobe(x)
#define BO_float32_letoh(x)  BO_float32_htole(x)
#define BO_float64_letoh(x)  BO_float64_htole(x)

// 位操作
#define BO_set_bit(number, x)    (number) |= (1U << (x))
#define BO_clear_bit(number, x)  (number) &= ~(1U << (x))
#define BO_toggle_bit(number, x) (number) ^= (1U << (x))
#define BO_check_bit(number, x)  (((number) >> (x)) & 1U)
#define BO_change_bit(number, n, x) \
    (number) = ((number) & ~(1U << (n))) | (((x) != 0) << (n))


STATIC_INLINE void BO_swap_bytes(void *value, size_t bsize)
{
    // bsize must be one of: 2, 4, 8, ... bytes
    size_t i;
    uint8_t t;
    uint8_t *b = (uint8_t*) value;
    for (i = 0; i < bsize/2; ++i) {
        t = b[i];
        b[i] = b[bsize-i-1];
        b[bsize-i-1] = t;
    }
}

STATIC_INLINE void BO_swap_ub2(void *value)
{
    uint16_t *p = (uint16_t*)value;
    *p = BO_bswap16(*p);
}

STATIC_INLINE void BO_swap_ub4(void *value)
{
    uint32_t *p = (uint32_t*)value;
    *p = BO_bswap32(*p);
}

STATIC_INLINE void BO_swap_ub8(void *value)
{
    uint64_t *p = (uint64_t*)value;
    *p = BO_bswap64(*p);
}

STATIC_INLINE void BO_bytes_letoh(char *valbuf, size_t bsize)
{
    // 如果主机是大端序，需要交换字节
#if BO_BIG_ENDIAN
    BO_swap_bytes(valbuf, bsize);
#endif
}

STATIC_INLINE void BO_bytes_betoh(char *valbuf, size_t bsize)
{
    // 如果主机是小端序，需要交换字节
#if BO_LITTLE_ENDIAN
    BO_swap_bytes(valbuf, bsize);
#endif
}

STATIC_INLINE int64_t BO_bytes_letoh_i64(void* bbuf)
{
    const int64_t *pval = (int64_t*) bbuf;
    BO_bytes_letoh((char*)bbuf, sizeof(int64_t));
    return *pval;
}

STATIC_INLINE int64_t BO_bytes_betoh_i64(void* bbuf)
{
    const int64_t *pval = (int64_t*) bbuf;
    BO_bytes_betoh((char*)bbuf, sizeof(int64_t));
    return *pval;
}

// BO_htobeXX_buf() 函数用于将buf中的数据从主机端序转换成大端序
//
STATIC_INLINE void BO_htobe16_buf(void *buf)
{
#if BO_LITTLE_ENDIAN
    uint16_t *p = (uint16_t*)buf;
    *p = BO_bswap16(*p);
#endif
}

STATIC_INLINE void BO_htobe32_buf(void *buf)
{
#if BO_LITTLE_ENDIAN
    uint32_t *p = (uint32_t*)buf;
    *p = BO_bswap32(*p);
#endif
}

STATIC_INLINE void BO_htobe64_buf(void *buf)
{
#if BO_LITTLE_ENDIAN
    uint64_t *p = (uint64_t*)buf;
    *p = BO_bswap64(*p);
#endif
}

// BO_htoleXX_buf() 函数用于将buf中的数据从主机端序转换成小端序
//
STATIC_INLINE void BO_htole16_buf(void *buf)
{
#if BO_BIG_ENDIAN
    uint16_t *p = (uint16_t*)buf;
    *p = BO_bswap16(*p);
#endif
}

STATIC_INLINE void BO_htole32_buf(void *buf)
{
#if BO_BIG_ENDIAN
    uint32_t *p = (uint32_t*)buf;
    *p = BO_bswap32(*p);
#endif
}

STATIC_INLINE void BO_htole64_buf(void *buf)
{
#if BO_BIG_ENDIAN
    uint64_t *p = (uint64_t*)buf;
    *p = BO_bswap64(*p);
#endif
}

// BO_betohXX_buf() 函数用于将buf中的数据从大端序转换成主机端序
//
STATIC_INLINE void BO_betoh16_buf(void *buf)
{
#if BO_LITTLE_ENDIAN
    uint16_t *p = (uint16_t*)buf;
    *p = BO_bswap16(*p);
#endif
}

STATIC_INLINE void BO_betoh32_buf(void *buf)
{
#if BO_LITTLE_ENDIAN
    uint32_t *p = (uint32_t*)buf;
    *p = BO_bswap32(*p);
#endif
}

STATIC_INLINE void BO_betoh64_buf(void *buf)
{
#if BO_LITTLE_ENDIAN
    uint64_t *p = (uint64_t*)buf;
    *p = BO_bswap64(*p);
#endif
}

// BO_letohXX_buf() 函数用于将buf中的数据从小端序转换为主机端序
//
STATIC_INLINE void BO_letoh16_buf(void *buf)
{
#if BO_BIG_ENDIAN
    uint16_t *p = (uint16_t*)buf;
    *p = BO_bswap16(*p);
#endif
}

STATIC_INLINE void BO_letoh32_buf(void *buf)
{
#if BO_BIG_ENDIAN
    uint32_t *p = (uint32_t*)buf;
    *p = BO_bswap32(*p);
#endif
}

STATIC_INLINE void BO_letoh64_buf(void *buf)
{
#if BO_BIG_ENDIAN
    uint64_t *p = (uint64_t*)buf;
    *p = BO_bswap64(*p);
#endif
}

#if defined(__cplusplus)
}
#endif

#endif /* BYTE_ORDER_H__ */
