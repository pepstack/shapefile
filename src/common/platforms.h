/***********************************************************************************************
* Copyright ©2024-2025 Light Zhang <mapaware@hotmail.com>, MapAware Inc. ALL RIGHTS RESERVED.  *
*                                  MapAware License v1.0                                       *
* PERMISSION IS HEREBY GRANTED, FREE OF CHARGE, TO ANY PERSON OR ORGANIZATION OBTAINING A COPY *
* OF THE SOFTWARE COVERED BY THIS LICENSE TO USE, REPRODUCE, DISPLAY, DISTRIBUTE, EXECUTE, AND *
* TRANSMIT THE SOFTWARE, AND TO PREPARE DERIVATIVE WORKS OF THE SOFTWARE, AND TO PERMIT THIRD  *
* PARTIES TO WHOM THE SOFTWARE IS FURNISHED TO DO SO, ALL SUBJECT TO THE FOLLOWING :           *
*                                                                                              *
* THE COPYRIGHT NOTICES IN THE SOFTWARE AND THIS ENTIRE STATEMENT, INCLUDING THE ABOVE LICENSE *
* GRANT, THIS RESTRICTION AND THE FOLLOWING DISCLAIMER, MUST BE INCLUDED IN ALL COPIES OF THE  *
* SOFTWARE, IN WHOLE OR IN PART, AND ALL DERIVATIVE WORKS OF THE SOFTWARE, UNLESS SUCH COPIES  *
* OR DERIVATIVE WORKS ARE SOLELY IN THE FORM OF MACHINE - EXECUTABLE OBJECT CODE GENERATED BY  *
* A SOURCE LANGUAGE PROCESSOR.                                                                 *
*                                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS",WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING *
* BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,TITLE *
* AND NON - INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE   *
* SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,WHETHER IN CONTRACT,TORT OR OTHERWISE, *
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  *
* SOFTWARE.                                                                                    *
***********************************************************************************************/
/**
 * @file platforms.h
 * @brief Platform definition detection and configuration header
 *
 * This header provides platform detection macros and includes
 * platform-specific headers for consistent cross-platform development.
 *
 * @author Liang Zhang <350137278@qq.com>
 * @copyright © 2024-2025 mapaware.top All Rights Reserved.
 * @version 1.0.31
 * @since 2025-08-20 06:07:35
 * @date 2025-12-05 02:23:33
 */

#ifndef PLATFORMS_H__
#define PLATFORMS_H__

#ifdef __cplusplus
extern "C" {
#endif

/**
 * 操作系统检测
 */
#undef PLATFORM_CYGWIN
#undef PLATFORM_WINDOWS
#undef PLATFORM_MINGW
#undef PLATFORM_LINUX
#undef PLATFORM_MACOS
#undef PLATFORM_ANDROID
#undef PLATFORM_APPLE
#undef PLATFORM_ARCH_NON

/* 确保不定义 Linux 相关的宏 */
#ifdef _LINUX_GNUC
    #undef _LINUX_GNUC
#endif

#if defined(__CYGWIN__)
    /* Cygwin 环境 - 类 Linux 环境运行在 Windows 上 */
    #define PLATFORM_CYGWIN
    #define PLATFORM_NAME "Cygwin"
#elif defined(__MINGW32__) || defined(__MINGW64__)
    /* MinGW 环境 - GNU 开发环境运行在 Windows 上 */
    #define PLATFORM_MINGW
    #define PLATFORM_WINDOWS  // 同时定义为 Windows 平台
    #if defined(__MINGW64__)
        #define PLATFORM_NAME "MinGW64"
    #else
        #define PLATFORM_NAME "MinGW32"
    #endif
#elif defined(_WIN32) || defined(_WIN64)
    /* 原生 Windows 平台 (MSVC) */
    #define PLATFORM_WINDOWS
    #define PLATFORM_NAME "Windows"
#elif defined(__linux__) || defined(__gnu_linux__)
    /* Linux 平台 */
    #define PLATFORM_LINUX
    #define PLATFORM_NAME "Linux"
#elif defined(__APPLE__) && defined(__MACH__)
    /* macOS 平台 */
    #define PLATFORM_MACOS
    #define PLATFORM_NAME "macOS"
#else
    #define PLATFORM_NAME "Unknown"
    #error "Unsupported platform. Please check your compilation environment."
#endif

/**
 * 架构检测 - 数值定义
 */
#if defined(PLATFORM_ARCH_BITS)
    #undef PLATFORM_ARCH_BITS
#endif

// 1) 最可靠的指针大小直接检测
#if defined(__SIZEOF_POINTER__)
    #if __SIZEOF_POINTER__ == 8
        #define PLATFORM_ARCH_BITS    64
    #elif __SIZEOF_POINTER__ == 4
        #define PLATFORM_ARCH_BITS    32
    #endif

// 2) Windows 环境特殊处理（必须优先且正确）
#elif defined(_WIN64)
    // _WIN64 明确表示 64 位 Windows
    #define PLATFORM_ARCH_BITS    64
#elif defined(_WIN32)
    // _WIN32 在所有 Windows 程序中都定义，所以这里必须是 32 位
    #define PLATFORM_ARCH_BITS    32

// 3) 其他平台的 64 位检测
#elif defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) || \
      defined(__amd64__) || defined(__AMD64__) || \
      defined(__aarch64__) || defined(_M_ARM64) || defined(__ARM64__) || \
      defined(__powerpc64__) || defined(__ppc64__) || defined(_ARCH_PPC64) || \
      defined(__LP64__) || defined(__64BIT__)
    #define PLATFORM_ARCH_BITS    64

// 4) 其他平台的 32 位检测
#elif defined(__i386__) || defined(_M_IX86) || defined(__i386) || \
      defined(__arm__) || defined(_M_ARM) || defined(__ARM__) || \
      defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC) || \
      defined(__ILP32__)
    #define PLATFORM_ARCH_BITS    32
#endif

// 第二步：确定具体架构类型（基于已知位数）
#if PLATFORM_ARCH_BITS == 64
    #if defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) || \
            defined(__amd64__) || defined(__AMD64__)
        #define PLATFORM_ARCH_X64     1
        #define PLATFORM_ARCH_AMD64   1
        #define PLATFORM_ARCH_X86_64  1
    #elif defined(__aarch64__) || defined(_M_ARM64) || defined(__ARM64__)
        #define PLATFORM_ARCH_ARM64   1
    #elif defined(__powerpc64__) || defined(__ppc64__) || defined(_ARCH_PPC64)
        #define PLATFORM_ARCH_PPC64   1
    #else
        #error "Unable to determine specific platform arch (x86, ARM, etc.)."
    #endif
#elif PLATFORM_ARCH_BITS == 32
    #if defined(__i386__) || defined(_M_IX86) || defined(__i386)
        #define PLATFORM_ARCH_X86     1
        #define PLATFORM_ARCH_IA32    1
    #elif defined(__arm__) || defined(_M_ARM) || defined(__ARM__)
        #define PLATFORM_ARCH_ARM     1
    #elif defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC)
        #define PLATFORM_ARCH_PPC     1
    #else
        #error "Unable to determine specific platform arch (x86, ARM, etc.)."
    #endif
#else
    #error "Unable to determine platform bits (32/64)."
#endif

/**
 * 功能特性检测
 */
#ifndef PLATFORM_HAS_POSIX
    #if defined(PLATFORM_LINUX) || defined(PLATFORM_MACOS) || defined(PLATFORM_CYGWIN)
        #define PLATFORM_HAS_POSIX 1
    #else
        #define PLATFORM_HAS_POSIX 0
    #endif
#endif

#ifndef PLATFORM_HAS_WINAPI
    #if defined(PLATFORM_WINDOWS) || defined(PLATFORM_CYGWIN) || defined(PLATFORM_MINGW)
        #define PLATFORM_HAS_WINAPI 1
    #else
        #define PLATFORM_HAS_WINAPI 0
    #endif
#endif

#ifndef PLATFORM_HAS_STD_ATOMIC
    #if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || (defined(__cplusplus) && __cplusplus >= 201103L)
        #define PLATFORM_HAS_STD_ATOMIC 1
    #else
        #define PLATFORM_HAS_STD_ATOMIC 0
    #endif
#endif

/**
 * 编译器检测
 */
#if defined(__GNUC__)
    #define COMPILER_GCC 1

    // 平台检测和对齐宏: 16, 32
    #ifndef ALIGNED_AS
        #define ALIGNED_AS(x)  __attribute__((aligned(x)))
    #endif
#elif defined(__clang__)
    #define COMPILER_CLANG 1

    // 平台检测和对齐宏
    #ifndef ALIGNED_AS
        #define ALIGNED_AS(x)  __attribute__((aligned(x)))
    #endif
#elif defined(_MSC_VER)
    #define COMPILER_MSVC 1
    #define _TIMESPEC_DEFINED

    /* Type definitions for the basic sized types. */
    #include <basetsd.h>
    typedef SSIZE_T ssize_t;

    // 平台检测和对齐宏
    #ifndef ALIGNED_AS
        #define ALIGNED_AS(x)  __declspec(align(x))
    #endif
#else
    #define COMPILER_UNKNOWN 1

    // 平台检测和对齐宏
    #ifndef ALIGNED_AS
        #define ALIGNED_AS(x)
    #endif
#endif

/**
 * 定义 _POSIX_C_SOURCE=200809L 来指定使用 POSIX.1-2008 标准
 * 会包含 lseek 函数的声明
 * 跨平台可移植性
 * 严格的POSIX兼容
 * 避免 GNU 依赖
 */
#if _POSIX_C_SOURCE < 200809L
    #undef _POSIX_C_SOURCE
    #define _POSIX_C_SOURCE  200809L
#endif

/**
 * 针对 Windows 平台的定义
 */
#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

/**
 * 平台特定头文件包含
 */
#if defined(PLATFORM_CYGWIN)
    /* Cygwin 环境 - 类 Linux 环境运行在 Windows 上, 支持 Windows API */

    // 首先包含 Cygwin 配置头文件，以确保定义必要的宏
    #include <cygwin/config.h>

    // 在包含 Windows 头文件之前，定义一些关键类型
    // 这些类型在某些情况下可能没有被正确定义

    #ifndef CHAR
        typedef char CHAR;
    #endif

    #ifndef _WCHAR_T_DEFINED
        typedef unsigned short wchar_t;
        #define _WCHAR_T_DEFINED
    #endif

    #ifndef SHORT
        typedef short SHORT;
    #endif

    #ifndef LONG
        // 在 Cygwin 中，LONG 实际上是 int 类型 (__LONG32)
        typedef int LONG;
    #endif

    #ifndef BYTE
        typedef unsigned char BYTE;
    #endif

    #ifndef WORD
        typedef unsigned short WORD;
    #endif

    #ifndef DWORD
        typedef unsigned int DWORD;
    #endif

    #ifndef ULONG
        typedef unsigned int ULONG;
    #endif

    #ifndef USHORT
        typedef unsigned short USHORT;
    #endif

    // 添加一些额外的保护措施，防止类型冲突
    #ifdef _WINDEF_H
        #ifndef _CHAR_DEFINED
            #define _CHAR_DEFINED
        #endif

        #ifndef _SHORT_DEFINED
            #define _SHORT_DEFINED
        #endif

        #ifndef _LONG_DEFINED
            #define _LONG_DEFINED
        #endif

        #ifndef _BYTE_DEFINED
            #define _BYTE_DEFINED
        #endif

        #ifndef _WORD_DEFINED
            #define _WORD_DEFINED
        #endif

        #ifndef _DWORD_DEFINED
            #define _DWORD_DEFINED
        #endif

        #ifndef _ULONG_DEFINED
            #define _ULONG_DEFINED
        #endif

        #ifndef _USHORT_DEFINED
            #define _USHORT_DEFINED
        #endif
    #endif

    // 包含 Windows 头文件（必须在 Cygwin 头文件之后）
    // 注意：在 Cygwin 环境中，需要先包含 windef.h，避免 Interlocked 函数冲突
    #include <w32api/windef.h>

    // 在包含 windows.h 之前，定义宏以避免 Interlocked 函数冲突
    #define _InterlockedAnd _InterlockedAnd_cygwin
    #define _InterlockedOr _InterlockedOr_cygwin
    #define _InterlockedXor _InterlockedXor_cygwin

    #include <windows.h>

    // 包含 POSIX 头文件
    #include <unistd.h>
    #include <signal.h>
    #include <errno.h>
    #include <sched.h>
    #include <pthread.h>
    #include <sys/time.h>
    #include <sys/sysinfo.h>
    #include <sys/types.h>
    #include <strings.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <sys/socket.h>

    #define cpu_sched_yield() sched_yield()
#elif defined(PLATFORM_MINGW)
    /* MinGW 环境 - GNU 开发环境运行在 Windows 上 */

    #include <winsock2.h>
    #include <windows.h>
    #include <ws2tcpip.h>
    #include <intrin.h>   // Windows Only
    #include <process.h>
    #include <errno.h>

    /* 包含必要的 POSIX 兼容头文件 */
    #include <sys/time.h>
    #include <sys/types.h>
    #include <strings.h>

    #define stat64buf_t  struct __stat64
    #define lstat64      _stat64

    /* 主动让出当前线程的 CPU 执行时间片 */
    #define cpu_sched_yield()    SwitchToThread()

#elif defined(PLATFORM_WINDOWS)
    /* Windows 环境 (MSVC) */

    #ifdef _POSIX_C_SOURCE
        #undef _POSIX_C_SOURCE
    #endif

    #include <winsock2.h>
    #include <windows.h>
    #include <ws2tcpip.h>
    #include <intrin.h>   // Windows Only
    #include <process.h>
    #include <errno.h>

    #define stat64buf_t  struct __stat64
    #define lstat64      _stat64

    /* 主动让出当前线程的 CPU 执行时间片 */
    #define cpu_sched_yield()    SwitchToThread()

#elif defined(PLATFORM_LINUX)
    /* Linux 环境 */
    #if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 1)
        #error "GCC version must be 4.1.2 or higher"
    #endif

    #ifndef _LARGE_TIME_API
        #define _LARGE_TIME_API
    #endif

    // 启用64位文件操作
    #ifndef _LARGEFILE64_SOURCE
        #define _LARGEFILE64_SOURCE
    #endif

    #include <unistd.h>
    #include <signal.h>
    #include <errno.h>
    #include <sched.h>
    #include <pthread.h>
    #include <sys/stat.h>
    #include <sys/time.h>
    #include <sys/sysinfo.h>
    #include <sys/syscall.h>
    #include <strings.h>
    #include <sys/types.h>

    #ifndef _LINUX_GNUC
        #define _LINUX_GNUC
    #endif

    #define stat64buf_t  struct stat64

    #define cpu_sched_yield()  sched_yield()
#elif defined(PLATFORM_MACOS)
    /* macOS 环境 */
    #include <unistd.h>
    #include <signal.h>
    #include <errno.h>
    #include <sched.h>
    #include <pthread.h>
    #include <sys/time.h>
    #include <sys/sysctl.h>
    #include <libkern/OSAtomic.h>
    #include <strings.h>

    #define cpu_sched_yield()  sched_yield()

#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
    #include <sys/sysctl.h>
    #include <sys/types.h>
#else
    #include <unistd.h>
#endif

/* 通用头文件包含 */
#include <stdio.h>
#include <string.h>  // memset
#include <stdlib.h>  // 内存分配函数（malloc/free/realloc/calloc）
#include <stddef.h>  // 包含 offsetof 宏
#include <stdint.h>
#include <stdarg.h>  // va_list
#include <stdbool.h> // bool
#include <time.h>
#include <limits.h>
#include <assert.h>  // 只有定义 NDEBUG 才能优化掉 assert(x)

/**
 * 跨平台静态断言宏
 */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
    #if defined(_MSC_VER)
        /* Visual Studio */
        #define STATIC_ASSERT(cond, msg) static_assert(cond, #msg)
    #else
        /* C11 标准 */
        #define STATIC_ASSERT(cond, msg) _Static_assert(cond, msg)
    #endif
#elif defined(__cplusplus) && __cplusplus >= 201103L
    /* C++11 标准 */
    #define STATIC_ASSERT(cond, msg) static_assert(cond, msg)
#elif defined(__GNUC__) || defined(__clang__)
    /* GCC/Clang 扩展 */
    #define STATIC_ASSERT(cond, msg) \
        typedef char _STATIC_ASSERT_##msg[(cond) ? 1 : -1] __attribute__((unused))
#else
    /* 通用回退方案 */
    #define STATIC_ASSERT(cond, msg) \
        extern char _STATIC_ASSERT_##msg[(cond) ? 1 : -1]
#endif

/**
 * 仅仅 DEBUG 情况下生效
 */
#ifdef DEBUG
    #define DEBUG_ASSERT(x)   assert(x)
    #define DEBUG_PRINT(format, ...)  printf(format, ##__VA_ARGS__)
#else
    #define DEBUG_ASSERT(x)   ((void)0)
    #define DEBUG_PRINT(format, ...)  ((void)0)
#endif

/**
 * 消除未用警告: defined but not used
 */
#ifndef NO_WARNING_UNUSED
    #if defined(__GNUC__) || defined(__CYGWIN__)
        #define NO_WARNING_UNUSED(x) x __attribute__((unused))
    #else
        #define NO_WARNING_UNUSED(x) x
    #endif
#endif

/**
 * 静态内联函数定义
 */
#ifndef STATIC_INLINE
    #if defined(_MSC_VER)
        #define STATIC_INLINE  static __forceinline
    #elif defined(__GNUC__) || defined(__clang__)
        #define STATIC_INLINE  static inline __attribute__((always_inline, unused))
    #else
        #define STATIC_INLINE  static inline
    #endif
#endif

/**
 * 常用函数
 */
#if defined(_WIN32) && defined(_MSC_VER) && _MSC_VER < 1900

    // 对于 MSVC 2015 之前的版本，我们使用 _snprintf，并模拟 C99 的 snprintf 行为
    static int msc_fix_snprintf(char* str, size_t size, const char* format, ...)
    {
        va_list args;
        va_start(args, format);
        int ret = _vsnprintf(str, size, format, args);
        va_end(args);

        if (ret < 0 || ret >= size) {
            // 如果返回负值或不小于 size，则确保字符串以空字符结尾
            if (size > 0) {
                str[size - 1] = '\0';
            }
            // 尝试计算所需长度
            va_start(args, format);
            ret = _vscprintf(format, args);
            va_end(args);
        }
        return ret;
    }

    #define snprintf msc_fix_snprintf

    // Windows 安全清零
    #define bzero_secure(ptr, bsize)  SecureZeroMemory((PVOID)(ptr), (SIZE_T)(bsize))

#else // posix
    // Linux/macOS 安全清零
    #define bzero_secure(ptr, bsize)  explicit_bzero((void*)(ptr), (size_t)(bsize))
#endif

// 快速清零
#define bzero_fast(ptr, bsize)  memset((void*)(ptr), 0, (size_t)(bsize))

/**
 * 获取可用的 CPU 核心数量
 * 如果无法获取则返回 -1
 */
STATIC_INLINE int getcpucount(void)
{
    int cpu_count = -1;

#ifdef _WIN32
    /* Windows 系统 */
    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    cpu_count = sysinfo.dwNumberOfProcessors;
#elif defined(__linux__) || defined(__CYGWIN__)
    /* Linux 系统 */
    cpu_count = get_nprocs();
#elif defined(__APPLE__)
    /* macOS 系统 */
    int mib[4];
    size_t len = sizeof(cpu_count);

    /* 设置查询参数 */
    mib[0] = CTL_HW;
    mib[1] = HW_AVAILCPU;  // 可用的 CPU 数量

    sysctl(mib, 2, &cpu_count, &len, NULL, 0);

    if (cpu_count < 1) {
        /* 如果获取失败，尝试获取物理 CPU 数量 */
        mib[1] = HW_NCPU;
        sysctl(mib, 2, &cpu_count, &len, NULL, 0);
        if (cpu_count < 1) {
            cpu_count = 1;  // 默认值
        }
    }
#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
    /* BSD 系统 */
    size_t len = sizeof(cpu_count);
    int mib[2];

    mib[0] = CTL_HW;
    mib[1] = HW_NCPU;  // 或者使用 HW_NCPUONLINE 获取在线 CPU

    if (sysctl(mib, 2, &cpu_count, &len, NULL, 0) == -1) {
        cpu_count = -1;
    }
#else
    /* 其他 Unix-like 系统 */
    cpu_count = sysconf(_SC_NPROCESSORS_ONLN);
    if (cpu_count < 1) {
        cpu_count = sysconf(_SC_NPROCESSORS_CONF);
    }
#endif
    return cpu_count;
}

// 获取进程ID
STATIC_INLINE int getprocessid(void)
{
#ifdef _WIN32
    return (int)GetCurrentProcessId();
#else
    return (int)getpid();
#endif
}

// 获取线程ID
STATIC_INLINE int getthreadid(void)
{
#ifdef _WIN32
    return (int)GetCurrentThreadId();
#elif defined(__APPLE__)
    uint64_t thread_id;
    pthread_threadid_np(NULL, &thread_id);
    return (int)thread_id;
#elif defined(__linux__)
    // 尝试多种方法获取线程ID
    #if defined(_GNU_SOURCE)
        // 如果系统已经定义了 SYS_gettid（某些环境可能默认定义）
        return (int)syscall(SYS_gettid);
    #else
        // 回退到 pthread_self
        return (int)(intptr_t)pthread_self();
    #endif
#else
    // 其他 Unix 系统的回退方案
    return (int)(intptr_t)pthread_self();
#endif
}

#if defined(__cplusplus)
}
#endif

#endif /* PLATFORMS_H__ */
